% Generated by roxygen2 (4.0.2): do not edit by hand
\name{RaggedArrayNew}
\alias{RaggedArrayNew}
\title{Construct a new RaggedArray object}
\usage{
RaggedArrayNew(dataList = NULL, nvec = NULL, allocLen = NULL,
  growBy = NULL)
}
\arguments{
\item{dataList}{List of (numeric) vectors to fill the new object, or the results of a previous \code{object$serialize()}.}

\item{nvec}{Number of (column) vectors that object will store. This is constant over the lifespan of the object.  Defaults to \code{length(dataList)}.}

\item{allocLen}{Number of rows to allocate in underlying data matrix.   Object will grow as needed.  Defaults to \code{max(sapply(dataList, length))}.}

\item{growBy}{Number of rows to grow object data matrix by when reallocation is needed. Can be changed.  Defaults to \code{allocLen}.}
}
\value{
An object of (S4) class RaggedArray.
}
\description{
\code{RaggedArrayNew} constructs a new RaggedArray object, filling it with the provided data, if any. Either \code{dataList} or \code{nvec & allocLen} are mandatory.  Given one, the other(s) will be inferred. Alternately, if \code{dataList} is a serialized RaggedArray (e.g. is an R list with element \code{SerializedRaggedArray}), a new object will be created using the default List constructor. In this case, specs are silently ignored.

See \code{\link{RaggedArrayClass}} for methods to manipulate object.
}
\examples{
ragged <- RaggedArrayNew( list( 1:5, 1:6, 1:7))
all.equal(ragged, RaggedArrayNew( ragged$serialize() ))
str(ragged)
ragged$sapply(function(x) x*2)
head(ragged$data)
sourceCpp(system.file('examples', 'cpp', 'userSapplyFun.cpp', package='RaggedArray'))
ragged$sapplyC(FunTimes10)
}
\seealso{
Other Ragged.Array.Docs: \code{\link{RaggedArray-package}}
}

